import numpy as np
from matplotlib.pyplot import plot as pt
import matplotlib.pyplot as plt
from numpy.random import exponential, binomial, gamma
from numpy import exp
def simulate(n, v, f, pr, M, k, c, vth, tauv, tauvth, vth0, vthb, cvth, cv, alpha, tmax, delta_t):

    nlist=[]
    vlist=[]
    vthlist=[]
    tlist=[]
    prelist=[]
    postlist=[]

    tplot=[]
    vplot=[]
    nplot=[]
    vthplot=[]

    postvth=[]

    tcurr=0
    ratio = 0
    timer = delta_t
    while tcurr < tmax:
        t0=exponential(1/f) # action potential
        t1=exponential(1/(k*(M-n) + 1e-6)) # site gets occupied
        t2 = timer

        if t0 < t1 and t0 < t2: # AP occurrs
            b = binomial(n, pr)
            n-=b
            v+=c*b
            tmin = t0
            timer-=tmin
            prelist.append(tcurr+tmin)

        elif t1<t0 and t1<t2: # add a docked vesicle
            n+=1
            tmin = t1
            timer-=tmin

        else:
            tmin=t2
            timer = delta_t
            if tcurr >= ratio*tmax:
                nlist.append(n)
                vlist.append(v)
                vthlist.append(vth)
                tlist.append(tcurr)

        tplot.append(tcurr)
        vplot.append(v)
        nplot.append(n)
        vthplot.append(vth)

        tcurr += tmin
        if v>=vth:
            postlist.append(tcurr)
            postvth.append(vth)
            vth=get_vth(vth, v, cvth, alpha, cv)
            v=0

        # Update the continuous dynamics
        v=v*exp(-tmin/tauv)
        vth=vthb+(vth-vthb)*np.exp(-tmin/tauvth)

    Tlist = np.diff(postlist)
    Tmean = np.mean(Tlist)
    CVT2=np.var(Tlist)/Tmean**2
    FFn=np.var(nlist)/np.mean(nlist)
    FFv=np.var(vlist)/np.mean(vlist)

    return tlist, nlist, vlist, vthlist, prelist, postlist, Tmean, CVT2, FFn, FFv,\
        tplot, vplot, nplot, vthplot, postvth

def get_vth(vth, v, cvth, alpha, cv):
    return vth+cvth*(v/cv)**alpha


f=10
pr=0.2 
M=100
k=10
c=0.003
tauv=1
tauvth=1

n=0 # occupied states
v=0

vth0=0.3
vthb=0.2
vth=0.2

# alpha = 0  constant jumps
# cvth = 0  fixed threshold
cvth=0.1
alpha=0
cv=0.1

delta_t = 0.001
tmax = 20 # <-------------- TMAX

# =============================================================================
# res=simulate(n, v, f, pr, M, k, c, vth, tauv, tauvth, vth0, vthb, cvth, cv, alpha, tmax, delta_t)
# plt.plot(res[0],res[2])
# plt.plot(res[0],res[3])
# for x in res[5]:
#     plt.axvline(x=x, alpha=1, color='r')
# 
# #%%
# =============================================================================

# =============================================================================
# plt.plot(np.linspace(0, 0.4, 100),
#          [get_vth(v, H, cv, vth0) for v in range(100)])
# =============================================================================

navgs=1
Ta=[]
T0=[]
Ca=[]
C0=[]
for j in range(navgs):
    Taj=[]
    Caj=[]  
    T0j=[]
    C0j=[]
    xname='f'
    xlist=np.linspace(0.01, 100, 100)
    for i, x in enumerate(xlist):
        print(j, navgs, i, len(xlist))
        f=x
        res=simulate(n, v, f, pr, M, k, c, vth, tauv, tauvth, vth0, vthb,
                     0, cv, alpha, tmax, delta_t)
        res0=simulate(n, v, f, pr, M, k, c, vth, tauv, tauvth, vth0, vth0,
                      cvth, cv, alpha, tmax, delta_t)
    # =============================================================================
    ##               (n, v, f, pr, M, k, c, vth, tauv, tauvth, vth0, vthb, tmax, delta_t, None)
    # =============================================================================
        Taj.append(res[6])
        Caj.append(res[7])
        T0j.append(res0[6])
        C0j.append(res0[7])
    Ta.append(Taj)
    T0.append(T0j)
    Ca.append(Caj)
    C0.append(C0j)

Ta = np.mean(np.array(Ta), 0)
Ca = np.mean(np.array(Ca), 0)
T0 = np.mean(np.array(T0), 0)
C0 = np.mean(np.array(C0), 0)

fig, ax = plt.subplots(2,1, figsize=(4,3.5))
ax[0].set_title('Constant threshold jumps')
ax[0].plot(xlist, 1/Ta, color='blue',linestyle='--', label='adaptive threshold')
ax[0].plot(xlist, 1/T0, color='k', label='fixed threshold')
ax[0].set_xticks([])
ax[0].set_ylabel('Output frequency')
ax[0].legend()

ax[1].plot(xlist, C0, color='k')
ax[1].plot(xlist, Ca, color='b',linestyle='--')
ax[1].set_ylabel('Coefficient of\nvariation squared')
ax[1].set_xlabel('Input frequency (Hz)')
plt.show()

# -----------------------------------------------------------------------------

# =============================================================================
# tvals=[]
# FFvs=[]
# FFns=[]
# nfs=10
# fslist=np.linspace(1,100,nfs)
# for j, f in enumerate(fslist):
#     # Calculate test
#     Tsim=[]
#     FFnsim=[]
#     FFvsim=[]
#     nsim=10
#     for i in range(nsim):
#         print(j, nfs, i, nsim)
#         res=simulate(n, v, f, pr, M, k, c, 
#                     vth, tauv, tauvth, vth0, vthb, tmax, delta_t)
#         Tsim.append(res[6])
#         FFnsim.append(res[7])
#         FFvsim.append(res[8])
#     Tsim=np.mean(Tsim)
#     FFnsim=np.mean(FFnsim)
#     FFvsim=np.mean(FFvsim)
#     tvals.append(Tsim)
#     FFvs.append(FFvsim)
#     FFns.append(FFnsim)
#     
# plt.subplot(3,1,1)
# plt.plot(fslist, tmeanadapt(fslist, c, pr, k, M, tauv, vth), label='Teq')
# plt.plot(fslist, tvals, label='Tsim')
# plt.legend()
# plt.subplot(3,1,2)
# plt.plot(fslist, FFvadapt(fslist, c, pr, k, M, tauv, vth), label='FFveq')
# plt.plot(fslist, FFvs, label='FFvsim')
# plt.xlabel('input frequency')
# plt.legend()
# plt.subplot(3,1,3)
# plt.plot(fslist, FFnadapt(fslist, c, pr, k, M, tauv, vth), label='FFneq')
# plt.plot(fslist, FFns, label='FFnsim')
# plt.xlabel('input frequency')
# plt.legend()
# plt.show()
# 
# =============================================================================
# =============================================================================
# # Calculate test
# Tsim=[]
# FFnsim=[]
# FFvsim=[]
# nsim=100
# for i in range(nsim):
#     print(i, nsim)
#     _, _, _, _, _, _, T, FFn, FFv =simulate(n, v, f, pr, M, k, c, 
#                         vth, tauv, tauvth, vthb, tmax, delta_t)
#     Tsim.append(T)
#     FFnsim.append(FFn)
#     FFvsim.append(FFv)
# Tsim=np.mean(Tsim)
# FFnsim=np.mean(FFnsim)
# FFvsim=np.mean(FFvsim)
# =============================================================================

# =============================================================================
# res = simulate(n, v, f, pr, M, k, c, vth, tauv, tauvth, vth0, vthb, tmax, delta_t)
# Tsim=res[6]
# FFnsim=res[7]
# FFvsim=res[8]
# fig, ax = plt.subplots(2,1)
# ax[0].plot(res[9], res[10], label='v')
# ax[0].plot(res[9], res[12], label='vth')
# ax[0].plot(res[5], res[13], 'ro')
# ax[1].plot(res[9], res[11])
# ax[0].plot([],[],' ', label='Tmean={}'.format(np.around(Tsim, 3)))
# ax[0].set_xticks([])
# ax[0].set_ylabel('membrane potential')
# ax[1].set_ylabel('vesicles')
# ax[0].legend()
# plt.show()
# =============================================================================


# =============================================================================
# Teq = tauv*np.log(1 + ((k + f*pr)*vth0)/(c*f*k*M*pr*tauv - (k + f*pr)*vthb))
# FFneq=((k + f*pr)*(-((k**2*M**2)/(k + f*pr)**2) + (k*M*(2*k*M - f*(-2 + pr)*pr))/((k + f*pr)*(2*k - f*(-2 + pr)*pr))))/(k*M)
# FFveq=(c*(2*k**3*(1 + (-1 + M)*pr)*tauv - f**2*(-2 + pr)*pr**2*(1 \
#       + f*pr*tauv) + k**2*(2 + 2*(-1 + M)*pr - f*(-2 + pr)*pr*tauv) + \
#       f*k*pr*(4 + pr*(-3 + 2*M + 2*f*tauv))))/(2.*(k + \
#       f*pr)*(2*k - f*(-2 + pr)*pr)*(1 + k*tauv + f*pr*tauv))
# check=(c *f *k *M *pr* tauv)/(k + f *pr) - vthb/vth0>0
# print('check', check)
# print('T eq sim')
# print(Teq, Tsim)
# print('FFn eq sim')
# print(FFneq, FFnsim)
# print('FFv eq sim')
# print(FFveq, FFvsim)
# =============================================================================
