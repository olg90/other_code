import numpy as np
import os
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.pyplot import plot
from matplotlib.pyplot import plot as pt

###############################################################################
#
#                        Functions for reading in the data
#
###############################################################################

def read_data(ftype, fname, excel_dir, txt_dir):

    if ftype == 0:  # Excel file
        file_path = os.path.join(excel_dir, fname)
        data = pd.read_csv(file_path)
        return np.array(data)
    elif ftype == 1:  # Text file
        file_path = os.path.join(txt_dir, fname)
        data = pd.read_csv(file_path, header=None).values.flatten()
        return data
    else:
        print("Invalid file type. Please provide 0 for Excel file or 1 for text file.")

def get_filenames(excel_dir, txt_dir):
    excel_files = [f for f in os.listdir(excel_dir) if os.path.isfile(os.path.join(excel_dir, f))]
    txt_files = [f for f in os.listdir(txt_dir) if os.path.isfile(os.path.join(txt_dir, f))]
    return excel_files, txt_files

###############################################################################
#
#                  Functions defining the gating variables
#
###############################################################################

def ainf(V): 
    return (1 + np.exp(-(V + 31) / 6))**(-1 / 4)
def binf(V): 
    return (1 + np.exp((V + 66) / 7))**(-1 / 2)
def cinf(V): 
    return (1 + np.exp((V + 66) / 7))**(-1 / 2)

def winf(V): 
    return (1 + np.exp(-(V + 48) / 6))**(-1 / 4)
def zinf(V):
    zeta = 0.5
    return (1 - zeta) * (1 + np.exp((V + 71) / 10))**(-1) + zeta

def ninf(V):
    return (1 + np.exp(-(V + 15) / 5))**(-1 / 2)
def pinf(V): 
    return (1 + np.exp(-(V + 23) / 6))**(-1)

def minf(V): 
    return (1 + np.exp(-(V + 38) / 7))**(-1)
def hinf(V): 
    return (1 + np.exp((V + 65) / 6))**(-1)

def rinf(V): 
    return (1 + np.exp((V + 76) / 7))**(-1)

###############################################################################
#
#             Functions defining tau for gating variables
#
###############################################################################

def taua(V): 
    return (100*(7*np.exp((V + 60) / 14) + 29 * np.exp(-(V + 60) / 24))**(-1) + 0.1)*1e-3
def taub(V): 
    return (1000 * (14 * np.exp((V + 60) / 27) + 29 * np.exp(-(V + 60) / 24))**(-1) + 1)*1e-3
def tauc(V): 
    return (90 * (1 + np.exp(-(V + 66) / 17))**(-1) + 10)*1e-3

def tauw(V): 
    return (100 * (6 * np.exp((V + 60) / 6) + 16 * np.exp(-(V + 60) / 45))**(-1) + 1.5)*1e-3
def tauz(V): 
    return (1000 * (np.exp((V + 60) / 20) + np.exp(-(V + 60) / 8))**(-1) + 50)*1e-3

def taun(V): 
    return (100 * (11 * np.exp((V + 60) / 24) + 21 * np.exp(-(V + 60) / 23))**(-1) + 0.7)*1e-3
def taup(V): 
    return (100 * (4 * np.exp((V + 60) / 32) + 5 * np.exp(-(V + 60) / 22))**(-1) + 5)*1e-3

def taum(V): 
    return (10 * (5 * np.exp((V + 60)/18) + 36 * np.exp(-(V + 60) / 25))**(-1) + 0.04)*1e-3
def tauh(V): 
    return (100 * (7 * np.exp((V + 60) / 11) + 10 * np.exp(-(V + 60) / 25))**(-1) + 0.6)*1e-3

def taur(V): 
    return (10**5 * (237 * np.exp((V + 60) / 12) + 17 * np.exp(-(V + 60) / 14))**(-1) + 25)*1e-3

###############################################################################
#
#                             Functions for current
#
###############################################################################

def I_ext(i, I_ext_data):

    if  0 <= i < 5000:
        return 0
    if 5000 <= i < 25000:
        return I_ext_data[i-5000]
    if i >= 25000:
        return 0
# =============================================================================
#     return 0
# =============================================================================

###############################################################################
#
#                      set up parameters
#
###############################################################################

# Change the file directories to where you put the data
excel_dir = r'C:\Users\Oliver\Desktop\German group current data\excel_files'
txt_dir = r'C:\Users\Oliver\Desktop\German group current data\txt_files'

# Read in the data
dataname=0 # This is the file number in the directory, 0 is the 1st file, 1 is the 2nd file, etc...
enames, tnames = get_filenames(excel_dir, txt_dir)
data=read_data(0, enames[dataname], excel_dir, txt_dir)

# Parameter values (27 parameters)
Vdata = data[:, 0] # Membrane potential 
G = data[:, 1] # Conductance

C_m = 12e-12  # membrane capacitance (uF/cm^2)

# -----------------------------------------------------------------------------

# =============================================================================
# # (1.) Original
# gA = 0e-9 # fast activating K+ conductance
# gLT = 100e-9 # Low threshold K+ conductance
# gHT = 150e-9  # High threshold K+ conductance
# gNa = 1000e-9    # Fast activating sodium conductance
# gh = 10e-9  # Hyperpolarization-conductance
# glk = 2e-9  # Leakage conductance
# =============================================================================

# (2.) Low threshold potassium conductance matches AP's better+constant current
gA = 0e-9 # fast activating K+ conductance
gLT = 60e-9 # Low threshold K+ conductance # 
gHT = 150e-9  # High threshold K+ conductance
gNa = 1000e-9    # Fast activating sodium conductance
gh = 10e-9  # Hyperpolarization-conductance
glk = 2e-9  # Leakage conductance

#------------------------------------------------------------------------------

VK = -0.08  # potassium reverse potential
VNa = 0.055  # sodium reverse potential
Vh = -0.043  # hyperpolarizing reverse potential
Vlk = -0.065  # leakage reverse potential

# Initial conditions
V0 = -0.06  # initial membrane potential (mV)
a0 = 0 # Fast transient K+ current
b0 = 0  # Fast transient K+ current
c0 = 0  # Fast transient K+ current

w0 = 0.594  # Low-threshold K+ current
z0 = 0.608  # Low-threshold K+ current

n0 = 0.85  # High-threshold K+ current
p0 = 0  # High-threshold K+ current

m0 = 0.043  # sodium activation gating variable
h0 = 0.293  # sodium inactivation gating variable
r0 = 0.063  # Hyperpolarization current

# Time vector
tmin = 0
tmax = 30000
t = np.linspace(tmin, tmax, len(data))

# Get the chirp signal and create the I_ext data
f0 = 2.5          # Start frequency (Hz)
f1 = 2000         # End frequency (Hz)
t1_ms = 20000     # Duration of the chirp (milliseconds)
t1 = t1_ms / 1000  # Convert duration to seconds
k = (f1 - f0) / t1
t_ext = np.linspace(0, 20, 20000)
I_ext_data = np.sin(2 * np.pi * (f0 * t_ext + 0.5 * k * t_ext**2))

# Variables initialization
V = np.zeros(len(t))
a = np.zeros(len(t))
b = np.zeros(len(t))
c = np.zeros(len(t))
w = np.zeros(len(t))
z = np.zeros(len(t))
n = np.zeros(len(t))
p = np.zeros(len(t))
m = np.zeros(len(t))
h = np.zeros(len(t))
r = np.zeros(len(t))

# Set initial conditions
V[0] = V0
a[0] = a0
b[0] = b0
c[0] = c0
w[0] = w0
z[0] = z0
n[0] = n0
p[0] = p0
m[0] = m0
h[0] = h0
r[0] = r0

###############################################################################
#
#                             Run simulations
#
###############################################################################

# Iteratively solve the difference equations
dt = 1e-5 # time step for Euler equation

iA = []
iLT = []
iHT = []
iNA = []
ih = []
ilk = []
iE = []
iext = []
phi = 0.85

for i in range(1, len(data)):
    
    # Get all the current and voltage values and update the voltage
    i_A = gA * a[i-1]**4 * b[i-1] * c[i-1] * (V[i-1]- VK)
    i_LT = gLT * w[i-1]**4 * z[i-1] * (V[i-1] - VK)
    i_HT = gHT * (phi * n[i-1]**2 + (1 - phi) * p[i-1]) * (V[i-1] - VK)
    i_NA = gNa * m[i-1]**3 * h[i-1] * (V[i-1] - VNa)  # something weird
    i_h = gh * r[i-1] * (V[i-1] - Vh)  # something weird
    i_lk = glk * (V[i-1] - Vlk)
    i_E = G[i-1]* V[i-1]
    i_ext = 0 * I_ext(i-1, I_ext_data)+0.1e-9

    dVdt = -(1 / C_m) * (i_A + i_LT + i_HT + i_NA + i_h + i_lk + i_E - i_ext)
    V[i] = V[i-1] + dVdt * dt

    # Add all the current values to a list for plotting
    iA.append(i_A)
    iLT.append(i_LT)
    iHT.append(i_HT)
    iNA.append(i_NA)
    ih.append(i_h)
    ilk.append(i_lk)
    iE.append(i_E)
    iext.append(i_ext)

    # Add the current value of each gating variable to a list containing
    # all the previous values, for plotting
    
    q10=(3**((37-22)/10))
        
    a[i] = a[i-1] + ((ainf(V[i-1]*1e3) - a[i-1]) / taua(V[i-1]*1e3)) * dt * q10
    b[i] = b[i-1] + ((binf(V[i-1]*1e3) - b[i-1]) / taub(V[i-1]*1e3)) * dt * q10
    c[i] = c[i-1] + ((cinf(V[i-1]*1e3) - c[i-1]) / tauc(V[i-1]*1e3)) * dt * q10
    w[i] = w[i-1] + ((winf(V[i-1]*1e3) - w[i-1]) / tauw(V[i-1]*1e3)) * dt * q10
    z[i] = z[i-1] + ((zinf(V[i-1]*1e3) - z[i-1]) / tauz(V[i-1]*1e3)) * dt * q10
    n[i] = n[i-1] + ((ninf(V[i-1]*1e3) - n[i-1]) / taun(V[i-1]*1e3)) * dt * q10
    p[i] = p[i-1] + ((pinf(V[i-1]*1e3) - p[i-1]) / taup(V[i-1]*1e3)) * dt * q10
    m[i] = m[i-1] + ((minf(V[i-1]*1e3) - m[i-1]) / taum(V[i-1]*1e3)) * dt * q10
    h[i] = h[i-1] + ((hinf(V[i-1]*1e3) - h[i-1]) / tauh(V[i-1]*1e3)) * dt * q10
    r[i] = r[i-1] + ((rinf(V[i-1]*1e3) - r[i-1]) / taur(V[i-1]*1e3)) * dt * q10

###############################################################################
#
#                             Plot simulations
#
###############################################################################

fs = 10
plt.subplot(3,1,1)
# =============================================================================
# plt.title('Hodgkin-Huxley-type model - chirp input from 2.5 Hz to 2kHz', fontsize=fs)
# =============================================================================
plt.title('Hodgkin-Huxley-type model', fontsize=fs)
plt.xlabel('time (ms)', fontsize=fs)
plt.ylabel('membrane Potential (mV)', fontsize=fs)
plt.plot(t, data[:, 0], label=enames[dataname], color='#ff7f0e')
plt.plot(t, V, label='siulations V(t)', color='#1f77b4')
plt.tick_params(axis='both', labelsize=fs)
plt.grid(True, alpha=0.3)
plt.legend(fontsize=fs, loc='upper right')
gvs=[a,b,c,w,z,n,p,m,h,r]
gn=['a','b','c','w','z','n','p','m','h','r']

plt.subplot(3,1,2)
for i in range(len(gvs)):
    plt.plot(gvs[i], label='{}'.format(gn[i]))
plt.legend()
plt.ylabel('gating variables')

plt.subplot(3,1,3)
ivals=[iA, iLT, iHT, iNA, ih, ilk, iE, iext]
inames=['i_A', 'i_LT', 'i_HT', 'i_NA', 'i_h', 'i_lk', 'i_E', 'i_ext']
for i in range(len(inames)):
    if inames[i] != 'i_ext':
        plt.plot(ivals[i], label='{}'.format(inames[i]))
plt.ylabel('current')
plt.xlabel('time (ms)')
plt.legend()
plt.show()
