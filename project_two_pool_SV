import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
def simulate(nstim, n0):
    bhist=[]
    n=n0
    tfire=1/f
    e=1e-6
    while len(bhist)<nstim:
        tfill=np.random.exponential(1/(k*(M-n)+e))
        if tfire<tfill:
            b=np.random.binomial(n,pr)
            n=n-b
            bhist.append(b)
            tfire=1/f
        if tfill<tfire:
            n=n+1
            tfire-=tfill
    return np.array(bhist)
def fun(i):
# =============================================================================
#     A0=0.1
#     A1=0.2
#     A2=0.1
#     c1=1
#     c2=1
#     i1=10
#     i2=20
#     return (A1-A0)/(1+np.exp(-c1*(i-i1)))+(A2-A1)/(1+np.exp(-c2*(i-i2)))+A0
# =============================================================================
# =============================================================================
#     return f*i*np.exp(-k*i)/(f*i+1)
# =============================================================================
# =============================================================================
#     return (i/f)/(f+(i/f)**2)
# =============================================================================
    return (i/f)*np.exp(-i/f)
def get_hill(x, x0,x1,Hx,cx):
    return (x1*(x/cx)**Hx+x0)/(1+(x/cx)**Hx)
def bval(i, pr, M , k, f, n0):
    # i means the ith AP, which is i/f seconds in
    # i >= 1
# =============================================================================
#     H=1.5
#     cx=10
#     x0=0.1# start
#     x1=0# end
#     pr=get_hill(i, x0, x1, H, cx) # hill function
# =============================================================================
# =============================================================================
#     k=fun(i)
#     A=(1-pr)*M*(1-np.exp(-k/f))
#     B=(1-pr)*np.exp(-k/f)
#     n_i_minus_1 = A*(1-B**(i-1))/(1-B)+B**(i-1)*n0
#     return pr*M*(1-np.exp(-k/f))+pr*np.exp(-k/f)*n_i_minus_1
# =============================================================================

    def Q(n,i, pr):
        return np.prod(pr[n-1:i])
    A=M*(1-np.exp(-k/f))
    B=np.exp(-k/f)
    
    x = np.sum([pr[z]*B**(-z)*Q(z,i, pr) for z in range(0, i-1)])
    return pr[i-1]*A+A*B**(i-1)*x+pr[0]*n0*B**i*Q(1,i-1, pr)
# =============================================================================
# data=pd.read_csv(r'C:\Users\olgud\OneDrive\Desktop\PhD\1-Classes\Biomedical Modeling\Project data.csv')
# =============================================================================
data=pd.read_csv(r'C:\Users\ogamb\OneDrive\Desktop\Project data.csv')
d=data.iloc[:, 3]
d1 = np.array([x for x in d if np.isnan(x)==False])
d=data.iloc[:, 2]
d5 = np.array([x for x in d if np.isnan(x)==False])
d=data.iloc[:, 1]
d2 = np.array([x for x in d if np.isnan(x)==False])
# Main Code -------------------------------------------------------------------
def get_pr(f, k, dlen):
    i=np.arange(dlen)
# =============================================================================
#     pr = 0.1*np.exp(-0.03*x) # <-------------- edit here, 2 Hz
# =============================================================================
# =============================================================================
#     pr = 0.9*np.exp(-0.05*x) # <-------------- edit here
# =============================================================================
# =============================================================================
#     c = 1.5
#     p0 = 0.4
#     R0 = 0.3
#     pr=(np.exp(-(c + f) * x) * (np.exp(c * x) * f * R0 + np.exp(f * x) * (c * p0 - f * (p0 + R0)))) / (c - f)
# =============================================================================
    
    pr = i*np.exp(-i)+0.5*np.exp(-i/f/k)
    return pr
fs=[100,50,2]
k=10
M=100
n0=0
nstim=len(d1)
# =============================================================================
# pr=get_pr(f, k, nstim) # must be len = 48
# =============================================================================
prs=[get_pr(f,k,nstim) for f in fs]
# =============================================================================
# sim=[simulate(nstim, n0) for i in range(10000)]
# msim = np.mean(sim, axis=0)
# plt.plot(msim/msim[0], label='sim', color='purple')
# =============================================================================
# =============================================================================
# times=np.linspace(0,100,100)
# plt.plot(times,pr*M*k/(f*pr+k)*(1-np.exp(-k*times)), label='bmean t')
# =============================================================================
indices = np.arange(1, nstim + 1)
# =============================================================================
# plt.subplot(1,2,1)
# =============================================================================
plt.scatter(indices, d1 / d1[0], label='100 Hz', color='red', 
            marker='o', linewidth=1, s=10)
plt.scatter(indices, d5 / d5[0], label='50 Hz', color='green',
            marker='o', linewidth=1, s=10)
plt.scatter(indices, d2 / d2[0], label='2 Hz', color='blue',
            marker='o', linewidth=1, s=10)
bratios = [[bval(i, prs[j], M, k, fs[j], n0) / bval(1, prs[j], M, k, fs[j], n0) for i in indices] for j in range(len(fs))]

cs=['red', 'green', 'blue']
ns=[100, 50, 2]
for i in range(len(prs)):
    plt.plot(indices, bratios[i], label='{} Hz'.format(ns[i]), 
            linewidth=1, color=cs[i])
plt.ylabel('normalized burst size')
plt.xlabel('stimulus #')
# =============================================================================
# ss=(np.exp(k/f)*M*(-1+np.exp(k/f)))/(((-1 + np.exp(k/f))*M + n0)*(-1+np.exp(k/f)+pr))
# plt.axhline(y=ss, xmin=0, xmax=100, color='orange')
# =============================================================================
plt.axhline(y=0, xmin=0, xmax=100, color='k')
for i in range(len(prs)):
    plt.plot(indices, prs[i], 
             label='pr-{} Hz'.format(fs[i]), color=cs[i], linestyle='--')

plt.legend(loc='upper right')
# =============================================================================
# plt.xscale('log')
# =============================================================================
# =============================================================================
# plt.ylim([0, 3])
# =============================================================================
# =============================================================================
# plt.xlim(0.95, nstim)  # Adjust x-axis limits to ensure the first point is shown
# =============================================================================
# =============================================================================
# plt.subplot(1,2,2)
# plt.plot(fun(indices))
# plt.xlabel("stimulus #")
# plt.title('Rate')
# plt.show()
# =============================================================================
# =============================================================================
# plt.subplot(1,2,2)
# plt.plot(pr)
# plt.xlabel("stimulus #")
# plt.title('Probability')
# plt.show()
# =============================================================================
if max(pr)>1:
    plt.axvline(x=25, color='k', linestyle='--')
    raise Exception('pmax>1')
if min(pr)<0:
    plt.axvline(x=25, color='k', linestyle='--')
    raise Exception('pmin<0')
