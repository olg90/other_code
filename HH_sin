import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

# Constants
C_m = 1.0   # membrane capacitance (uF/cm^2)
g_Na = 120.0  # maximum conductances (mS/cm^2)
g_K = 36.0
g_L = 0.3
E_Na = 50.0   # reversal potentials (mV)
E_K = -77.0
E_L = -54.387

# Define model constants: membrane capacitance (C_m),
# maximum conductances of sodium (g_Na), potassium (g_K), and leak (g_L) channels,
# and reversal potentials for sodium (E_Na), potassium (E_K), and leak (E_L).

# Channel gating kinetics
def alpha_m(V):
    return 0.1*(V + 40.0) / (1.0 - np.exp(-(V + 40.0) / 10.0))

def beta_m(V):
    return 4.0 * np.exp(-(V + 65.0) / 18.0)

def alpha_h(V):
    return 0.07 * np.exp(-(V + 65.0) / 20.0)

def beta_h(V):
    return 1.0 / (1.0 + np.exp(-(V + 35.0) / 10.0))

def alpha_n(V):
    return 0.01*(V + 55.0) / (1.0 - np.exp(-(V + 55.0) / 10.0))

def beta_n(V):
    return 0.125 * np.exp(-(V + 65) / 80.0)

# Define functions for voltage-dependent rate constants (alpha and beta)
# for the activation (m) and inactivation (h) of sodium channels,
# and for the activation (n) of potassium channels.

# Membrane currents
def I_Na(V, m, h):
    return g_Na * m**3 * h * (V - E_Na)

def I_K(V, n):
    return g_K  * n**4 * (V - E_K)

def I_L(V):
    return g_L * (V - E_L)

# External current
def I_ext(t, frequency=0.1, amplitude=10):
    return amplitude * np.sin(2 * np.pi * frequency * t)

# Define an external sinusoidal current function (I_ext)
# with specified frequency and amplitude.


def get_x(xinf, x, taux, V):
    return (xinf-x)/taux

def ainf(V):
    return (1+np.exp(-(V+31)/6))**(-1/4)
def binf(V):
    return (1+np.exp(V+66/7))**(-1/2)
def cinf(V):
    return (1+np.exp(V+66/7))**(-1/2)

def winf(V):
    return (1+np.exp(-(V+48))/6)**(-1/4)
def zinf(V):
    zeta=0.5
    return (1-zeta)*(1+np.exp((V+71)/10))**(-1)+zeta

def ninf(V):
    return (1+np.exp(-(V+15)/5))**(-1/2)
def pinf(V):
    return (1+np.exp(-(V+23)/6))**(-1)

def minf(V):
    return (1+np.exp(-(V+38)/7))**(-1)
def hinf(V):
    return (1+np.exp((V+65)/6))**(-1)

def taua(V):
    return 100*(7*np.exp((V+60)/14)+29*np.exp(-(V+60)/24))**(-1)+0.1
def taub(V):
    return 1000*(14*np.exp((V+60)/27)+29*np.exp(-(V+60)/24))**(-1)+1
def tauc(V):
    return 90*(1+np.exp(-(V+66)/17))**(-1)+10
def tauw(V):
    return 100*(6*np.exp((V+60)/6)+16*np.exp(-(V+60)/45))**(-1)+1.5
def tauz(V):
    return 1000*(np.exp((V+60)/20)+np.exp(-(V+60)/8))**(-1)+50

def taun(V):
    return 100*(11*np.exp((V+60)/24)+21*np.exp(-(V+60)/23))**(-1)+0.7
def taup(V):
    return 100*(4*np.exp((V+60)/32)+5*np.exp(-(V+60)/22))**(-1)+5

def taum(V):
    return 10*(5*np.exp((V+60))+36*np.exp(-(V+60)/25))**(-1)+0.04
def tauh(V):
    return 100*(7*np.exp((V+60)/11)+10*np.exp(-(V+60)/25))**(-1)+0.6

# Hodgkin-Huxley equations
def dXdt(t, X):
    V, m, h, n = X # all defined variables values go here

    dVdt=1/(C_m)*(I_A(gA,a,b,c,V,Vk)+
                  I_LT(gLT,w,z,V,VK)+
                  I_HT(gHT,phi,n,p,V,VK)+
                  I_Na(gNA,m,h,V,VNa)+
                  I_h(gh,r,V,Vh)+
                  I_lk(glk,V,Vlk)+
                  I_E(ge,t,tauE,V,VE)
                  -I_ext(t, amplitude, frequency))

    dadt = get_x(ainf(V),a,taua(V))
    dbdt = get_x(binf(V),b,taub(V))
    dcdt = get_x(cinf(V),c,tauc(V))

    dwdt = get_x(winf(V), w, tauw(V))
    dzdt = get_x(zinf(V), z, tauz(V))

    dndt = get_x(ninf(V), n, taun(V))
    dpdt = get_x(pinf(V), p, taup(V))

    dmdt = (1+np.exp(-(V+38)/7))**(-1)
    dhdt = (1+np.exp((V+65)/6))**(-1)

    return [dVdt, dmdt, dhdt, dndt]

def I_A(gA,a,b,c,V,Vk):
    return ga*a^4*b*c*(V-Vk)

def I_LT(gLT,w,z,V,VK):
    return gLT*w**4*z*(V-VK)



def I_HT(gHT,n,p,V,VK):
    phi=0.85
    return gHT*(phi*n**2+(1-phi)*p)*(V-VK)

def I_Na(gNA, m, h, V, VNa):
    return gNA*m**3*h*(V-VNa)

def I_h(gh,r,V,Vh):
    return gh*r*(V-Vh)

def rinf(V):
    return (1+np.exp((V+76)/7))**(-1)

def taur(V):
    10**5*()














# Define the system of ordinary differential equations (ODEs)
# describing the Hodgkin-Huxley model.
# This function dXdt(t, X) computes the derivatives of the state variables
# V (membrane potential), m (sodium activation gating variable),
# h (sodium inactivation gating variable), and n (potassium gating variable).

# Initial conditions
V0 = -65.0  # initial membrane potential (mV)
m0 = 0.05   # initial sodium activation gating variable
h0 = 0.6    # initial sodium inactivation gating variable
n0 = 0.32   # initial potassium gating variable

# Time vector
t_span = (0, 100)  # simulation time span
t_eval = np.linspace(*t_span, 1000)  # time points to evaluate

# Solve ODE
sol = solve_ivp(dXdt, t_span, [V0, m0, h0, n0], t_eval=t_eval)

# Use solve_ivp from scipy.integrate to solve the system of ODEs (dXdt)
# with the specified initial conditions ([V0, m0, h0, n0])
# and evaluate the solution at the specified time points (t_eval).

# Plot results
plt.figure(figsize=(10, 6))
plt.plot(sol.t, sol.y[0], label='Membrane Potential (mV)')
plt.xlabel('Time (ms)')
plt.ylabel('Membrane Potential (mV)')
plt.title('Hodgkin-Huxley Model with Sinusoidal Current')
plt.legend()
plt.grid(True)
plt.show()

# Plot the membrane potential over time from the ODE solution.
# This visualizes the dynamics of the Hodgkin-Huxley model
# with an external sinusoidal current input.
